/// @file
#pragma once
/// @date 2024-10-21 (last modification)
#ifndef HEADER_NodeAsMap_INCLUDED
#define HEADER_NodeAsMap_INCLUDED

/**
* @brief Node implementation based on hash map.
* @internal "https://docs->oracle->com/javase/6/docs/api/java/util/HashMap.html"
*/

#include "iVisNode_class.pde.hpp"

#include "Node_class.pde.hpp"
//Base class is now:
#define _superclass _

/// @note Automatically extracted definition of `class`: NodeAsMap

//_endOfSuperClass; // Now will change of superclass!
//Base class is now:
#define _superclass _
//_derivedClass:NodeAsMap

class NodeAsMap : public  Node, public virtual iVisNode , public virtual Object{
  public:
  
  //pHashMap<int,pLink> connections; //TODO using Object::hashCode(). Could be a bit faster than String
  pHashMap<String,pLink> connections; 
  
  NodeAsMap()
  {
    connections=new HashMap<String,pLink>(); 
  }
  
  int     numOfConn()      {
	 return connections->size();
	}
  
  int     addConn(piLink   l)
  {
     return addConn((Link)l);
  }
  
  int     addConn(pLink   l)
  {
    assert(l!=nullptr );	//  String("Empty link in ")+this->getClass().getName()+ String("->addConn(Link)?"); 
    if(NET_DEBUG>2 && l->target==this) //It may not be expected!
            print("Self connecting of",l->target->name());
            
    //int hash=l->target->hashCode();//((Object)this)->hashCode() for HashMap<int,pLink>      
    String key=l->target->name();
    pLink old=connections->put(key,l); 
    
    if(old==nullptr)
      return   1;
    else
      return 0;
  }
  
  int     delConn(piLink   l)
  {
    assert(false );	//  String("Not implemented ")+this->getClass().getName()+String("->delConn(Link ")+l+ String(") called"); 
    return   -1;
  }
  
  pLink    getConn(int    i)
  {
    assert(i>=connections->size());	// String("Index '")+i+String("' out of bound '")+connections.size()+String("' in ")+this->getClass()->getName()+ String("->getConn(int)"); 
    assert(false);	//  "Non optimal use of NodeMap in getConn(int)";
    int counter=0;
    for(auto<String,pLink> ent:connections->entrySet())
    {
      if(i==counter) 
          return ent->getValue();
      counter++;
    }
    return nullptr;
  }
  
  pLink    getConn(piNode   n)
  {
    assert(n!=nullptr );	//  String("Empty node in ")+this->getClass().getName()+ String("->getConn(Node)"); 
    String key=n->name();
    return connections->get(key);
  }
  
  pLink    getConn(String k)
  {
    assert(k==nullptr || k=="" );	//  String("Empty string in ")+this->getClass().getName()+ String("->getConn(String)"); 
    return connections->get(k);
  }
  
  sarray<pLink>  getConns(piLinkFilter f)
  {
    assert(f!=nullptr );	//  String("Empty LinkFilter in ")+this->getClass().getName()+ String("->getConns(LinkFilter)"); 
    pArrayList<pLink> selected=new ArrayList<pLink>();
    for(auto<String,pLink> ent:connections->entrySet())
    {
      if(f->meetsTheAssumptions(ent->getValue())) 
            selected->add(ent->getValue());
    }
    sarray<pLink> ret=new array<pLink>(selected->size());
    selected->toArray(ret);
    return ret;
  }

  // REMAINING INTERFACES REQUIREMENTS:
  //*//////////////////////////////////
  color defColor() {
	 return color(255,128); 
	}
  float     getX() {
	 return posX(); 
	}
  float     getY() {
	 return posY(); 
	}
  float     getZ() {
	 return 0; 
	}
  String getName() {
	 return name();
	}
  
} ; //_EndOfClass_


//Undefining any base class preprocessor definition: _
#undef _superclass

/// Generated by Processing2C++ extraction Tools
#endif //HEADER_NodeAsMap_INCLUDED

//MADE NOTE: /data/wb/SCC/public/Processing2C/scripts did it 2024-10-21 19:06:46 !

