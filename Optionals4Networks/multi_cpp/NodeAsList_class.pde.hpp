/// @file
#pragma once
/// @date 2024-10-21 (last modification)
#ifndef HEADER_NodeAsList_INCLUDED
#define HEADER_NodeAsList_INCLUDED

/**
* @brief Node implementation based on `ArrayList.`
* @internal "https://docs->oracle->com/javase/8/docs/api/java/util/ArrayList.html"
*/

#include "iVisNode_class.pde.hpp"

#include "Node_class.pde.hpp"
//Base class is now:
#define _superclass _

/// @note Automatically extracted definition of `class`: NodeAsList

//_endOfSuperClass; // Now will change of superclass!
//Base class is now:
#define _superclass _
//_derivedClass:NodeAsList

class NodeAsList : public  Node, public virtual iVisNode , public virtual Object{
  public:

  pArrayList<pLink> connections; 
  
  NodeAsList()
  {
    connections=new ArrayList<pLink>();
  }
  
  int     numOfConn()  //!< By interface required.    
  {
	 return connections->size(); 
	}
  
  int     addConn(piLink   l)
  {
     return addConn((Link)l);
  }
  
  int     addConn(pLink   l) //!< By interface required.
  {
                                          assert(l!=nullptr );	//  String("Empty link in ")+this->getClass().getName()+ String("->addConn(Link)?");
    if(NET_DEBUG>2 && l->getTarget()==this)   //It may not be expected!
            print("Self connecting of",l->getTarget()->name());
            
    bool    res=false;
    
    if(getConn(l->getTarget())==nullptr)
    {
        res=connections->add(l);
        if(NET_DEBUG>1) print("* ");
    }
    else if(NET_DEBUG>1) println("Link",this->name(),
                                   "->",l->target->name(), // new line for C++ sed-translator
                                   "already exist"); // '.' should not be between '"' 

    if(res) return   1;
    else    return   0;
  }
  
  int     delConn(piLink   l) //!< By interface required.
  {
    if(connections->remove(l))
      return 1;
    else
      return 0;
  }
  
  pLink    getConn(int    i) //!< By interface required.
  {
    assert(i<connections->size());	//  String("Index '")+i+String("' out of bound '")+connections.size()+String("' in ")+this->getClass()->getName()+ String("->getConn(int)"); 
    return connections->get(i);
  }
  
  pLink    getConn(piNode   n) //!< By interface required.
  {
                                           assert(n!=nullptr );	//  String("Empty node in ")+this->getClass().getName()+ String("->getConn(Node)");
    for(pLink l:connections)
    {
      if(l->target==n) 
            return l;
    }
    return nullptr;
  }
  
  pLink    getConn(String k) //!< By interface required.
  {
                              assert(k==nullptr || k=="" );	//  String("Empty string in ")+this->getClass().getName()+ String("->getConn(String)");
    for(pLink l:connections)
    {
      if(l->target->name()==k) 
            return l;
    }
    return nullptr;
  }
  
  sarray<pLink>  getConns(piLinkFilter f) //!< By interface required.
  {
                            //assert(f!=nullptr );	//  String("Empty LinkFilter in ")+this->getClass().getName()+ String("->getConns(LinkFilter)");
    pArrayList<pLink> selected=new ArrayList<pLink>();
    for(pLink l:connections)
    {
      if(f==nullptr || f->meetsTheAssumptions(l)) 
            selected->add(l);
    }
    
    sarray<pLink> ret=new array<pLink>(selected->size());
    selected->toArray(ret);
    return ret;
  } //<>//
  
  // REMAINING INTERFACES REQUIREMENTS:
  //*//////////////////////////////////
  color defColor() {
	 return color(0,128); 
	}
  float     getX() {
	 return posX(); 
	}
  float     getY() {
	 return posY(); 
	}
  float     getZ() {
	 return 0; 
	}
  String getName() {
	 return name();
	}
  
} ; //_EndOfClass_


//Undefining any base class preprocessor definition: _
#undef _superclass

/// Generated by Processing2C++ extraction Tools
#endif //HEADER_NodeAsList_INCLUDED

//MADE NOTE: /data/wb/SCC/public/Processing2C/scripts did it 2024-10-21 19:06:46 !

